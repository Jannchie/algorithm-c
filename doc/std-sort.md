# 算法入门 - 冒泡、选择、插入 - 三大基本排序

排序是一种把**一组数据按照一定顺序排列**的算法。

你必须掌握排序，因为他们既基础，又重要。很少有这样一类问题被反复用不同姿势解决这么多次。

排序入门，最基础简单且最慢（时间复杂度为`O(n)`）的三种排序分别是**冒泡、选择和插入排序**。

## 冒泡排序

### 冒泡排序的过程

如有`n`个数需要从小到大排序，可以从数组的第一位开始，也就是第`1`个元素开始，与后一位（第`2`个元素）比较，如果后者比前者还小，则将两数对调。再比较当前第`2`个元素与第`3`个元素的大小，同样如果前比后大则对调。以此类推，最终在一轮循环过后，整个数组中最大的元素就会位于数组的最后方。接下来只需要对前`n - 1`个元素进行排序，排序方式同上，最终的结果会让倒数第二大的元素排列到倒数第二位。不断地进行这样的操作，便使得数组按照从小到大排列。

整个排序的过程中，较大的数字不断地从数组前方往后冒，因此被形象地称之为“冒泡排序”。

![冒泡排序示意图-c](media/15727675860629.gif)[^bubble_sort_graph]

### 冒泡排序的优势

#### 冒泡排序是稳定的排序

说实话，虽然这几种最土的排序，都要两次循环，他们的时间复杂度都是$O(n^2)$，但是在运行过程中，由于每次只能相邻的两个元素进行比较，导致比较和数值交换的次数实在是太多了。但多出来的操作能够保证排序是稳定的，这是冒泡排序的特征之一。

> **什么是稳定的排序？** 
> 
> 在排序中，如果两个元素的大小相同，那么他们排序前和排序后的相对位置也相同。上述这种排序就被称作稳定的排序。
> 
> 比如整理扑克牌时，如果要求数字从小到大排列，如果排序前，方片A在黑桃A的前面，而排序后，方片A跑到了黑桃A的后面，则是不稳定的。

#### 原数组越有序，冒泡效率越高

冒泡排序相较于其他骚气的排序，比较好的一点是，它往往不会把简单的问题复杂化。如若给定的是一个几乎排序完成的数组，那么冒泡排序需要的实际遍历次数可以很少。优化过的冒泡排序代码甚至可以在排序中检查出是否已经排列完成，并提前退出。

### 冒泡排序的缺点

#### 慢、慢如蜗牛

由于冒泡排序需要不断地交换两个元素的位置，导致其效率严重低下，只要有效率需求，就不建议使用，人生苦短，请不要冒泡。

不过注意，上述所说的是最原生态的冒泡排序，事实上还有很多改进版本，可以很显著地提高速度，但那就不完全称作冒泡排序了。

### 冒泡排序的实现

冒泡排序的实现C语言源码如下所示。

``` c
/**
 * @name: 冒泡排序
 * @author: Jannchie
 * @date: 2019-10-22
 * */
void bubbleSort(int a[], int len)
{
    // i为每轮冒泡的目标位置
    for (int i = len; i > 0; i--)
    {
        // 从第2个元素开始比较
        for (int j = 1; j < i; j++)
        {
            // 如果该元素比前一个元素小
            if (a[j] < a[j - 1])
            {
                //则将前一个元素向前冒泡
                swap(&a[j - 1], &a[j]);
            }
        }
    }
}
```

## 选择排序

### 选择排序的过程

选择排序其实比冒泡排序更容易理解。

在冒泡排序中，一趟排序的结果是什么？是让最大的一个元素，放到还没排序的那部分的最后。而中间还有很多步看上去没什么必要的交换操作。正是这些交换操作，导致排序变得很慢。

一个看上去更加简单也更加好想的方式是这样的：

- 遍历一遍元素，在遍历过程中，记住最大的那个元素。
- 遍历结束后，将最大的元素和最后一个元素对调。
- 再次遍历剩下的元素，重复上述操作。

如此一来，便可以把整个数组排序。

选择排序和冒泡排序非常相似。区别在于，冒泡排序需要不断地在相邻两者之间比较，而选择排序牛逼在有一格记忆力，可以记住最大的元素，一步到位，直接将最大的放在最后。

### 选择排序的优势

选择排序的优势在于简单。它比任何一种排序方式都要直观，用一句话来描述就是：每次选择一个最大的元素放在最后。

![选择排序示意图-c](media/15730404444806.gif)

### 选择排序的缺点

本质上，选择排序仍然是一种非常慢的排序，它由两层循环构成，时间复杂度为$O(n)$。

#### 选择排序的实现

``` c
/**
 * @name: 选择排序
 * @author: Jannchie
 * @date: 2019-10-22
 * */
void selectSort(int a[], int len)
{
    for (int i = 0; i < len - 1; i++)
    {
        int min = i;
        for (int j = i + 1; j < len; j++)
        {
            if (a[min] > a[j])
            {
                min = j;
            }
        }
        swap(&a[min], &a[i]);
    }
}
```

## 插入排序

### 插入排序的过程

插入排序的思想更贴近一个正常人的思路。插入排序类似于抓扑克牌，每次抓一张新的牌，把新的牌插入到应该放置的位置，保持手中的牌永远有序。

插入排序从第二个元素开始排序——因为第一个元素可以看成是，唯一一个已经排序完毕的元素。从第二个元素开始，与已经排好序的元素比较，如果新元素比已排序的最后一个元素还要小，说明失序，则需要进行插入操作。

接下来需要寻找插入点，并空出一个空间来，把新元素存入这个位置。如何空出空间？我们需要把新元素至插入点之间的元素，一个一个地往后挪动。

我们可以先临时保存新元素的值，这样的话，我们就可以把前一个元素赋值到这个位置了，把这个操作看作是挪动。挪完再拿新元素的值与更前面一个点比较，新如果比它更小说明还需要再往前面移动才行，直到遇到一个比新元素更大的元素，此时最后一个挪动的元素，它原来的位置可以看作是一个空位，把新元素的值放在这里，就算大功告成。

还有一种可能是，找到第一个元素，还是比新来的元素大，则说明这个元素是最小的元素了，那么需要把它安排在第一位。

![插入排序示意图-c](media/15730419374779.gif)

### 插入排序的优势

插入排序是一种看上去比较高级的排序方式。相较于冒泡和选择，也确实更加高效。并且，原数组越有序，排序效率越高。

插入排序由于永远是两个临近的元素进行比较，因此也是一种稳定的排序。

插入排序在增量排序中效率极高。也就是说，如果要在一个已经排序的数组中插入一个新的元素，使用插入排序是最好的选择。

插入排序在数据规模较小的时候或许比其他更高级的排序更为有效。因此，许多高级排序的最后关头，会退化成插入排序进行最后的收尾工作，因此这也是最实用的一种排序方式。

### 插入排序的缺点

作为一个两次循环构成的$O(n^2)的排序，在数据量极大时效率很差。在那些情况下，更适合使用快速排序、堆排序、归并排序等高级排序算法。

此外，虽然插入排序的算法和思想也很简单，但插入排序的书写比起其他两个弱鸡算法，更加困难一些。

### 插入排序的实现

``` c
/**
 * @name: 插入排序
 * @author: Jannchie
 * @date: 2019-10-22
 * */
void insertSort(int a[], int len)
{
    for (int i = 1; i < len; i++)
    {
        if (a[i] < a[i - 1])
        {
            int temp = a[i], j;
            for (j = i - 1; j >= 0 && a[j] > temp; j--)
            {
                a[j + 1] = a[j];
            }
            a[j] = temp;
        }
    }
}
```
